
# from external
import numpy as np
import healpy as hp
import sys
import pickle
import tqdm

# from act library
sys.path.append("/global/homes/t/toshiyan/Work/Lib/actlib/actsims/")
sys.path.append("/global/homes/t/toshiyan/Work/Lib/actlib/soapack/")
sys.path.append("/global/homes/t/toshiyan/Work/Lib/actlib/")
sys.path.append("/global/homes/t/toshiyan/Work/Lib/actlib/orphics/")
sys.path.append("/global/homes/t/toshiyan/Work/Lib/actlib/tilec/")
from actsims import simgen, noise
from pixell import enmap
from soapack import interfaces

# from cmblensplus/wrap/
import curvedsky

# from cmblensplus/utils/
import misctools

# from this directory
import local


def coadd_real_data(qid,mask):
    # Compute coadded map by simply summing up each split with the inverse variance weight 
    
    # First, read survey parameters from qid
    model, season, array, patch, freq = local.qid_info(qid[0])
    
    # for consistency with noise sim which is generated with uncalibrated data, the ivars are not multiplied by the cal factor.

    # Day time data
    if model == 'dr5':
        dm = interfaces.models['dr5'](region=mask)
        datas = enmap.enmap( [ dm.get_splits( q, calibrated=True ) for q in qid ] )
        ivars = enmap.enmap( [ dm.get_ivars( q, calibrated=False ) for q in qid ] )        

        # coadded map
        map_c = mask[None,None,:,:] * np.average( datas*ivars, axis=1 )

    # Night time data
    if model == 'act_mr3':
        dm = interfaces.models['act_mr3'](region=mask,calibrated=True)
        datas = dm.get_splits(season=season,patch=patch,arrays=dm.array_freqs[array],srcfree=True)
        dm = interfaces.models['act_mr3'](region=mask,calibrated=False)
        ivars = dm.get_splits_ivar(season=season,patch=patch,arrays=dm.array_freqs[array])

        # coadded map
        map_c = mask[None,None,:,:] * np.average( datas*ivars, axis=1 )

    return map_c


def get_cal(qid):
    # obtain calibration factor from qid
    # see soapack for the values of cal factors
    
    model, season, array, patch, freq = local.qid_info(qid)
                
    if model == 'dr5':
        dm = interfaces.models['dr5']()
        return  dm.get_gain(qid)
        
    if model == 'act_mr3':
        dm = interfaces.models['act_mr3']()
        return  dm.cals[season][patch][array]['cal']
        
                    
def generate_map(qids,overwrite=False,verbose=True,**kwargs):
    # Here we compute the real coadd map and simulated maps from the noise covariance and pre-computed fullsky signal
    # This function uses actsims "simgen" code

    for qid in qids:
        
        if qid in ['boss_d04','s16_d03']:
            # Here, the simulation is performed for each array, not frequency, to take into account their correlation
            # For pa3, there are two frequency bands
            if verbose:
                print('skip '+qid+': the map is generated by running f090 case.')
            continue
        
        if '_d0' in qid:
            version = 'v6.3.0_calibrated_mask_version_masks_20200723'
        else:
            version = 'v6.3.0_calibrated_mask_version_padded_v1'

        # define qid_array to take into account multi-frequency case 
        if qid == 'boss_d03':
            qid_array = ['boss_d03','boss_d04']
        elif qid == 's16_d02':
            qid_array = ['s16_d02','s16_d03']
        elif qid == 'boss_03':
            qid_array = ['boss_03','boss_04']            
        else:
            # single frequency case
            qid_array = [qid]

        # define filename
        aobj = {}
        for q in qid_array:
            aobj[q] = local.init_analysis_params(qid=q,**kwargs)

        # load mask
        mask = load_mask(qid)

        # Define an object for sim generation
        model, season, array, patch, __ = local.qid_info(qid)
        if model == 'dr5':
            simobj = simgen.SimGen(version=version,qid=qid_array,model=model)
        if model == 'act_mr3':
            simobj = simgen.SimGen(version=version,model=model)

        # loop over realizations
        for i in tqdm.tqdm(aobj[qid].rlz):
            
            if misctools.check_path(aobj[qid].fmap['s'][i],overwrite=overwrite,verbose=verbose): continue

            # maps will have signal ('s') and noise ('n') and each has [Nfreq, NTPol, Coord1, Coord2]
            maps = {}

            # real data
            if i == 0: 
                maps['s'] = coadd_real_data(qid_array,mask)
            # simulation
            else:
                map_s, map_n, ivars = simobj.get_sim(season, patch, array, sim_num=i, set_idx=0)
                maps['s'] = mask[None,None,:,:] * np.average( map_s*ivars, axis=1 ) 
                maps['n'] = mask[None,None,:,:] * np.average( map_n*ivars, axis=1 )

                # noise is generated with uncalibrated data
                for qi, q in enumerate(qid_array):
                    if verbose: print('apply cal factor to noise sim',get_cal(q))
                    maps['n'][qi,:,:,:] *= get_cal(q)

                for qi, q in enumerate(qid_array):
                    if not misctools.check_path(aobj[q].fivar,overwrite=overwrite,verbose=verbose): 
                        enmap.write_map( aobj[q].fivar, np.average(ivars[qi,:,:,:,:],axis=0) )

            # save signal and noise to files
            # data is saved to a signal file
            for s in ['s','n']:
                if s=='n' and i==0: continue
                for qi, q in enumerate(qid_array):
                    enmap.write_map(aobj[q].fmap[s][i],maps[s][qi,:,:,:])


                
def load_mask(qid):    
    # load mask by specifying qid
    
    model, season, array, patch, freq = local.qid_info(qid)
    
    if model == 'dr5':
        mask = interfaces.get_binary_apodized_mask(qid)
    
    elif model == 'act_mr3':
        mask = interfaces.get_act_mr3_crosslinked_mask(patch,version='padded_v1',kind='binary_apod',season=season,array=array+"_"+freq,pad=None)

    return mask


def load_mask_with_ivar(qid):
    
    mask = load_mask(qid)
    aobj = local.init_analysis_params(qid=qid)
    ivar = enmap.read_map(aobj.fivar)
    
    return mask[None,:,:]*ivar


def get_wfactor(mask,wnmax=5):
    wn = np.zeros(wnmax)
    for n in range(1,wnmax):
        wn[n] = np.average(mask**n)
    wn[0] = np.average(mask/(mask+1e-30))
    return wn
    
                
def define_lmask(shape,wcs, lxcut = None, lycut = None, lmin = None, lmax = None):
    # copied from orphics
    output = np.ones(shape[-2:], dtype = int)
    if (lmin is not None) or (lmax is not None): modlmap = enmap.modlmap(shape, wcs)
    if (lxcut is not None) or (lycut is not None): ly, lx = enmap.laxes(shape, wcs, oversample=1)
    if lmin is not None:
        output[np.where(modlmap <= lmin)] = 0
    if lmax is not None:
        output[np.where(modlmap >= lmax)] = 0
    if lxcut is not None:
        output[:,np.where(np.abs(lx) < lxcut)] = 0
    if lycut is not None:
        output[np.where(np.abs(ly) < lycut),:] = 0
    return output
    

def remove_lxly(fmap,lmin=100,lmax=4096):
    alm = enmap.fft(fmap)
    shape, wcs = fmap.shape, fmap.wcs
    kmask = define_lmask(shape,wcs,lmin=lmin,lmax=lmax,lxcut=90,lycut=50)
    alm[kmask<0.5] = 0
    fmap_fl = enmap.ifft(alm).real
    return fmap_fl


def map2alm_core(fmap,lmin=100,lmax=4096,nside=2048):
    fmap_fl = remove_lxly(fmap,lmin=lmin,lmax=lmax)
    hpmap = enmap.to_healpix(fmap_fl,nside=nside)
    alm = curvedsky.utils.hp_map2alm(nside,lmax,lmax,hpmap)
    return alm


def beam_func(lmax,qid):
    
    dm = interfaces.models['dr5']()
    L  = np.arange(0, lmax+100, dtype=np.float)
    Bl = dm.get_beam_func(L, qid)
    return Bl[:lmax+1]


def map2alm(qids,overwrite=False,verbose=True,**kwargs):

    for qid in qids: 
        
        aobj = local.init_analysis_params(qid=qid,**kwargs)
        Bl = beam_func(aobj.lmax,qid)
                
        for i in tqdm.tqdm(aobj.rlz):
        
            if misctools.check_path(aobj.falm['c']['T'][i],overwrite=overwrite,verbose=verbose): continue
            
            if i == 0: 
            
                maps_c = enmap.read_map(aobj.fmap['s'][0])
                alm_c = map2alm_core(maps_c[0,:,:],lmax=aobj.lmax,nside=aobj.nside)
                alm_c /= Bl[:,None]
                pickle.dump((alm_c),open(aobj.falm['c']['T'][i],"wb"),protocol=pickle.HIGHEST_PROTOCOL)

            else:
                
                maps_s = enmap.read_map(aobj.fmap['s'][i])
                maps_n = enmap.read_map(aobj.fmap['n'][i])

                alm_s = map2alm_core(maps_s[0,:,:],lmax=aobj.lmax,nside=aobj.nside)
                alm_n = map2alm_core(maps_n[0,:,:],lmax=aobj.lmax,nside=aobj.nside)
                alm_s /= Bl[:,None]
                alm_n /= Bl[:,None]

                pickle.dump((alm_s),open(aobj.falm['s']['T'][i],"wb"),protocol=pickle.HIGHEST_PROTOCOL)
                pickle.dump((alm_n),open(aobj.falm['n']['T'][i],"wb"),protocol=pickle.HIGHEST_PROTOCOL)
                pickle.dump((alm_s+alm_n),open(aobj.falm['c']['T'][i],"wb"),protocol=pickle.HIGHEST_PROTOCOL)



def alm2aps_core(lmax,falm,w2=1.,mtype=['T']):

    cl = np.zeros((6,lmax+1))
    
    # compute cls
    if 'T' in mtype:  
        Talm = pickle.load(open(falm['T'],"rb"))
        cl[0,:] = curvedsky.utils.alm2cl(lmax,Talm)

    if 'E' in mtype:  
        Ealm = pickle.load(open(falm['E'],"rb"))
        cl[1,:] = curvedsky.utils.alm2cl(lmax,Ealm)

    if 'B' in mtype:  
        Balm = pickle.load(open(falm['B'],"rb"))
        cl[2,:] = curvedsky.utils.alm2cl(lmax,Balm)

    if 'T' in mtype and 'E' in mtype:
        cl[3,:] = curvedsky.utils.alm2cl(lmax,Talm,Ealm)

    if 'T' in mtype and 'B' in mtype:
        cl[4,:] = curvedsky.utils.alm2cl(lmax,Talm,Balm)

    if 'E' in mtype and 'B' in mtype:
        cl[5,:] = curvedsky.utils.alm2cl(lmax,Ealm,Balm)

    return cl/w2
        

def alm2aps(qids,overwrite=False,verbose=True,mtype=['T'],**kwargs):

    for qid in qids: 
        
        aobj = local.init_analysis_params(qid=qid,**kwargs)
        
        mask_iv = load_mask_with_ivar(qid)
        mask_hp = enmap.to_healpix(mask_iv,nside=aobj.nside)
        wn = get_wfactor(mask_hp)

        cl = {}
        for s in ['c','n']:
            cl[s] = np.zeros((len(aobj.rlz),6,aobj.lmax+1))


        for ii, rlz in enumerate(tqdm.tqdm(aobj.rlz)):

            if misctools.check_path(aobj.fcls['c'][rlz],overwrite=overwrite,verbose=verbose): continue

            if rlz == 0:
                fnames = { m: aobj.falm['c'][m][rlz] for m in mtype }
                cl['c'][ii,:,:] = alm2aps_core(aobj.lmax,fnames,w2=wn[2],mtype=mtype)
            else:
                for s in ['c','n']:
                    fnames = { m: aobj.falm[s][m][rlz] for m in mtype }
                    cl[s][ii,:,:] = alm2aps_core(aobj.lmax,fnames,w2=wn[2],mtype=mtype)
 
            # save cl for each rlz
            np.savetxt(aobj.fcls['c'][rlz],np.concatenate((aobj.l[None,:],cl['c'][ii,:,:])).T)
            np.savetxt(aobj.fcls['n'][rlz],np.concatenate((aobj.l[None,:],cl['n'][ii,:,:])).T)

        # save mean cl to files
        if aobj.rlz[-1] >= 2:
            if verbose:  print('save averaged spectrum over rlz')
            imin = max(0,1-aobj.rlz[0]) 
            for s in ['c','n']:
                if misctools.check_path(aobj.fscl[s],overwrite=overwrite,verbose=verbose): continue
                np.savetxt(aobj.fscl[s],np.concatenate((aobj.l[None,:],np.mean(cl[s][imin:,:,:],axis=0),np.std(cl[s][imin:,:,:],axis=0))).T)


def alm2aps_null(qid,overwrite=False,verbose=True,mtype=['T'],ep=1e-30,**kwargs):

    aobj = {}
    pid = qid.replace('_d0','_0')
    if 's16' in qid:
        pid = qid.replace('s16','boss')

    for q in [qid,pid]:
        aobj[q] = local.init_analysis_params(qid=q,**kwargs)

    mask_iv0 = load_mask_with_ivar(qid)
    mask_hp0 = enmap.to_healpix(mask_iv0,nside=aobj[qid].nside)
    mask_iv1 = load_mask_with_ivar(pid)
    mask_hp1 = enmap.to_healpix(mask_iv1,nside=aobj[pid].nside)

    w2 = np.average(mask_hp0**2)
    x2 = np.average(mask_hp0*mask_hp1)

    cl = np.zeros((len(aobj[qid].rlz),6,aobj[qid].lmax+1))
    xl = np.zeros((len(aobj[qid].rlz),6,aobj[qid].lmax+1))

    for ii, rlz in enumerate(tqdm.tqdm(aobj[qid].rlz)):

        #if misctools.check_path(aobj[qid].fnul['c'][rlz],overwrite=overwrite,verbose=verbose): continue

        Talm0 = pickle.load(open(aobj[qid].falm['c']['T'][rlz],"rb"))
        Talm1 = pickle.load(open(aobj[pid].falm['c']['T'][rlz],"rb"))
        cl[ii,0,:] = curvedsky.utils.alm2cl(aobj[qid].lmax,Talm0-Talm1) / w2
        xl[ii,0,:] = curvedsky.utils.alm2cl(aobj[qid].lmax,Talm0,Talm1) / x2
        
        # save cl for each rlz
        np.savetxt(aobj[qid].fcls_nul[rlz],np.concatenate((aobj[qid].l[None,:],cl[ii,:,:])).T)
        np.savetxt(aobj[qid].fcls_x[rlz],np.concatenate((aobj[qid].l[None,:],xl[ii,:,:])).T)

    # save mean cl to files
    if aobj[qid].rlz[-1] >= 2:
        if verbose:  print('cmb alm2aps: save sim')
        imin = max(0,1-aobj[qid].rlz[0]) 
        np.savetxt(aobj[qid].fscl_nul,np.concatenate((aobj[qid].l[None,:],np.mean(cl[imin:,:,:],axis=0),np.std(cl[imin:,:,:],axis=0))).T)
        np.savetxt(aobj[qid].fscl_x,np.concatenate((aobj[qid].l[None,:],np.mean(xl[imin:,:,:],axis=0),np.std(xl[imin:,:,:],axis=0))).T)


