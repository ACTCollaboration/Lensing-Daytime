
# from external
import numpy as np
import healpy as hp
import sys
import pickle
import tqdm

# from act library
sys.path.append("/global/homes/t/toshiyan/Work/Lib/actlib/actsims/")
sys.path.append("/global/homes/t/toshiyan/Work/Lib/actlib/soapack/")
sys.path.append("/global/homes/t/toshiyan/Work/Lib/actlib/")
sys.path.append("/global/homes/t/toshiyan/Work/Lib/actlib/orphics/")
sys.path.append("/global/homes/t/toshiyan/Work/Lib/actlib/tilec/")
from actsims import simgen, noise
from pixell import enmap
from soapack import interfaces

# from cmblensplus/wrap/
import curvedsky

# from cmblensplus/utils/
import misctools

# from this directory
import local


def coadd_real_data(qid,mask,dg=2):
    # Compute coadded map by simply summing up each split with the inverse variance weight 

    assert mask.ndim == 2

    # First, read survey parameters from qid
    model, season, array, patch, freq = local.qid_info(qid[0])
    
    # for consistency with noise sim which is generated with uncalibrated data, the ivars are not multiplied by the cal factor.

    # Day time data
    if model == 'dr5':
        dm = interfaces.models['dr5'](region=mask)
        datas = enmap.enmap( [ dm.get_splits( q, calibrated=True ) for q in qid ] )
        ivars = enmap.enmap( [ dm.get_ivars( q, calibrated=False ) for q in qid ] )

    # Night time data
    if model == 'act_mr3':
        dm = interfaces.models['act_mr3'](region=mask,calibrated=True)
        datas = dm.get_splits(season=season,patch=patch,arrays=dm.array_freqs[array],srcfree=True)
        dm = interfaces.models['act_mr3'](region=mask,calibrated=False)
        ivars = dm.get_splits_ivar(season=season,patch=patch,arrays=dm.array_freqs[array])

    # normalize
    ivars = ivars_normalize(ivars)

    # coadded map
    map_c = mask[None,None,:,:] * np.average( datas*ivars, axis=1 )
    
    # downgrade
    map_c = enmap.downgrade(map_c, dg)
    assert map_c.ndim == 4

    return map_c


def ivars_normalize(ivars):
    
    n1, n2, n3 = np.shape(ivars[:,:,:,0,0])
    nivars = 0.*ivars
    for i in range(n1):
        for j in range(n2):
            for k in range(n3):
                nivars[i,j,k,:,:] = ivars[i,j,k,:,:]/np.max(ivars[i,j,k,:,:])
    #nivars = ivars
    return nivars
    

def get_cal(qid):
    # obtain calibration factor from qid
    # see soapack for the values of cal factors
    
    model, season, array, patch, freq = local.qid_info(qid)
                
    if model == 'dr5':
        dm = interfaces.models['dr5']()
        return  dm.get_gain(qid)
        
    if model == 'act_mr3':
        dm = interfaces.models['act_mr3']()
        return  dm.cals[season][patch][array+'_'+freq]['cal']
        
                    
def generate_map(qids,overwrite=False,verbose=True,dg=2,**kwargs):
    # Here we compute the real coadd map and simulated maps from the noise covariance and pre-computed fullsky signal
    # This function uses actsims "simgen" code

    for qid in qids:
        
        if qid in ['boss_d04','s16_d03','boss_04']:
            # Here, the simulation is performed for each array, not frequency, to take into account their correlation
            # For pa3, there are two frequency bands
            if verbose:
                print('skip '+qid+': the map is generated by running f090 case.')
            continue
        
        if '_d0' in qid:
            version = 'day'
        else:
            version = 'night'

        # define qid_array to take into account multi-frequency case 
        if qid == 'boss_d03':
            qid_array = ['boss_d03','boss_d04']
        elif qid == 's16_d02':
            qid_array = ['s16_d02','s16_d03']
        elif qid == 'boss_03':
            qid_array = ['boss_03','boss_04']            
        else:
            # single frequency case
            qid_array = [qid]

        # define filename
        aobj = {}
        for q in qid_array:
            aobj[q] = local.init_analysis_params(qid=q,**kwargs)

        # load mask
        mask = load_mask(qid,dg=1,with_ivar=False)[0]

        # Define an object for sim generation
        model, season, array, patch, __ = local.qid_info(qid)
        if model == 'dr5':
            simobj = simgen.SimGen(version=version,qid=qid_array,model=model)
        if model == 'act_mr3':
            simobj = simgen.SimGen(version=version,model=model)

        # loop over realizations
        for i in tqdm.tqdm(aobj[qid].rlz):
            
            if misctools.check_path(aobj[qid].fmap['s'][i],overwrite=overwrite,verbose=verbose): continue

            # maps will have signal ('s') and noise ('n') and each has [Nfreq, NTPol, Coord1, Coord2]
            maps = {}

            # real data
            if i == 0: 
                maps['s'] = coadd_real_data(qid_array,mask) / local.Tcmb
            # simulation
            else:
                maps['s'], maps['n'], ivars = simobj.get_sim(season, patch, array, sim_num=i, set_idx=0)
                
                # normalize
                ivars = ivars_normalize(ivars)

                # coadd
                maps['s'] = mask[None,None,:,:] * np.average( maps['s']*ivars, axis=1 ) / local.Tcmb
                maps['n'] = mask[None,None,:,:] * np.average( maps['n']*ivars, axis=1 ) / local.Tcmb

                # downgrade
                maps['s'] = enmap.downgrade(maps['s'], dg)
                maps['n'] = enmap.downgrade(maps['n'], dg)
                ivars = enmap.downgrade(ivars, dg)

                # noise is generated with uncalibrated data
                for qi, q in enumerate(qid_array):
                    if verbose: print('apply cal factor to noise sim',get_cal(q))
                    maps['n'][qi,:,:,:] *= get_cal(q)

                for qi, q in enumerate(qid_array):
                    if not misctools.check_path(aobj[q].fivar,overwrite=overwrite,verbose=verbose): 
                        enmap.write_map( aobj[q].fivar, np.average(ivars[qi,:,:,:,:],axis=0) )

            # save signal and noise to files
            # data is saved to a signal file
            for s in ['s','n']:
                if s=='n' and i==0: continue
                for qi, q in enumerate(qid_array):
                    enmap.write_map(aobj[q].fmap[s][i],maps[s][qi,:,:,:])


                
def load_mask_core(qid):    
    # load mask by specifying qid
    
    model, season, array, patch, freq = local.qid_info(qid)
    
    if model == 'dr5':
        mask = interfaces.get_binary_apodized_mask(qid)
    
    elif model == 'act_mr3':
        mask = interfaces.get_act_mr3_crosslinked_mask(patch,version='padded_v1',kind='binary_apod',season=season,array=array+"_"+freq,pad=None)

    return mask


def load_mask(qid,dg=2,with_ivar=True):
    
    mask = load_mask_core(qid)
    mask_dg = enmap.downgrade(mask,dg)
    if with_ivar:
        aobj = local.init_analysis_params(qid=qid)
        ivar = enmap.read_map(aobj.fivar)
    else:
        ivar = 1.
    
    return mask_dg[None,:,:]*ivar


def get_wfactor(mask,wnmax=5):
    wn = np.zeros(wnmax)
    for n in range(1,wnmax):
        wn[n] = np.average(mask**n)
    wn[0] = np.average(mask/(mask+1e-30))
    print('wfactors:',wn)
    return wn
    
                
def define_lmask(shape,wcs, lxcut = None, lycut = None, lmin = None, lmax = None):
    # copied from orphics
    output = np.ones(shape[-2:], dtype = int)
    if (lmin is not None) or (lmax is not None): modlmap = enmap.modlmap(shape, wcs)
    if (lxcut is not None) or (lycut is not None): ly, lx = enmap.laxes(shape, wcs, oversample=1)
    if lmin is not None:
        output[np.where(modlmap <= lmin)] = 0
    if lmax is not None:
        output[np.where(modlmap >= lmax)] = 0
    if lxcut is not None:
        output[:,np.where(np.abs(lx) < lxcut)] = 0
    if lycut is not None:
        output[np.where(np.abs(ly) < lycut),:] = 0
    return output
    

def remove_lxly(fmap,lmin=100,lmax=4096):
    alm = enmap.fft(fmap)
    shape, wcs = fmap.shape, fmap.wcs
    kmask = define_lmask(shape,wcs,lmin=lmin,lmax=lmax,lxcut=90,lycut=50)
    print(np.shape(kmask),np.shape(alm))
    alm[kmask<0.5] = 0
    fmap_fl = enmap.ifft(alm).real
    return fmap_fl


def map2alm_core(fmap,lmin=100,lmax=4096,nside=2048):
    fmap_fl = remove_lxly(fmap,lmin=lmin,lmax=lmax)
    hpmap = enmap.to_healpix(fmap_fl,nside=nside)
    alm = curvedsky.utils.hp_map2alm(nside,lmax,lmax,hpmap)
    return alm


def beam_func(lmax,qid):
    
    dm = interfaces.models['dr5']()
    L  = np.arange(0, lmax+100, dtype=np.float)
    Bl = dm.get_beam_func(L, qid)
    return Bl[:lmax+1]


def map2alm(qids,overwrite=False,verbose=True,**kwargs):

    for qid in qids: 
        
        aobj = local.init_analysis_params(qid=qid,**kwargs)
        Bl = beam_func(aobj.lmax,qid)
                
        for i in tqdm.tqdm(aobj.rlz):
        
            if misctools.check_path(aobj.falm['c']['T'][i],overwrite=overwrite,verbose=verbose): continue
            
            if i == 0: 
            
                maps_c = enmap.read_map(aobj.fmap['s'][0])
                print(np.shape(maps_c))
                alm_c = map2alm_core(maps_c[0,:,:],lmax=aobj.lmax,nside=aobj.nside)
                alm_c /= Bl[:,None]
                pickle.dump((alm_c),open(aobj.falm['c']['T'][i],"wb"),protocol=pickle.HIGHEST_PROTOCOL)

            else:
                
                maps_s = enmap.read_map(aobj.fmap['s'][i])
                maps_n = enmap.read_map(aobj.fmap['n'][i])

                alm_s = map2alm_core(maps_s[0,:,:],lmax=aobj.lmax,nside=aobj.nside)
                alm_n = map2alm_core(maps_n[0,:,:],lmax=aobj.lmax,nside=aobj.nside)
                alm_s /= Bl[:,None]
                alm_n /= Bl[:,None]

                pickle.dump((alm_s),open(aobj.falm['s']['T'][i],"wb"),protocol=pickle.HIGHEST_PROTOCOL)
                pickle.dump((alm_n),open(aobj.falm['n']['T'][i],"wb"),protocol=pickle.HIGHEST_PROTOCOL)
                pickle.dump((alm_s+alm_n),open(aobj.falm['c']['T'][i],"wb"),protocol=pickle.HIGHEST_PROTOCOL)



def alm2aps_core(lmax,falm,w2=1.,mtype=['T']):

    cl = np.zeros((6,lmax+1))
    
    # compute cls
    if 'T' in mtype:  
        Talm = pickle.load(open(falm['T'],"rb"))
        cl[0,:] = curvedsky.utils.alm2cl(lmax,Talm)

    if 'E' in mtype:  
        Ealm = pickle.load(open(falm['E'],"rb"))
        cl[1,:] = curvedsky.utils.alm2cl(lmax,Ealm)

    if 'B' in mtype:  
        Balm = pickle.load(open(falm['B'],"rb"))
        cl[2,:] = curvedsky.utils.alm2cl(lmax,Balm)

    if 'T' in mtype and 'E' in mtype:
        cl[3,:] = curvedsky.utils.alm2cl(lmax,Talm,Ealm)

    if 'T' in mtype and 'B' in mtype:
        cl[4,:] = curvedsky.utils.alm2cl(lmax,Talm,Balm)

    if 'E' in mtype and 'B' in mtype:
        cl[5,:] = curvedsky.utils.alm2cl(lmax,Ealm,Balm)

    return cl/w2
        

def alm2aps(qids,overwrite=False,verbose=True,mtype=['T'],Wn=None,**kwargs):

    for qid in qids: 
        
        aobj = local.init_analysis_params(qid=qid,**kwargs)
        
        if Wn is None:
            mask_iv = load_mask(qid)
            mask_hp = enmap.to_healpix(mask_iv,nside=aobj.nside)
            wn = get_wfactor(mask_hp)
        else:
            wn = Wn

        cl = {}
        for s in ['c','n']:
            cl[s] = np.zeros((len(aobj.rlz),6,aobj.lmax+1))


        for ii, rlz in enumerate(tqdm.tqdm(aobj.rlz)):

            if misctools.check_path(aobj.fcls['c'][rlz],overwrite=overwrite,verbose=verbose): continue

            if rlz == 0:
                fnames = { m: aobj.falm['c'][m][rlz] for m in mtype }
                cl['c'][ii,:,:] = alm2aps_core(aobj.lmax,fnames,w2=wn[2],mtype=mtype)
            else:
                for s in ['c','n']:
                    fnames = { m: aobj.falm[s][m][rlz] for m in mtype }
                    cl[s][ii,:,:] = alm2aps_core(aobj.lmax,fnames,w2=wn[2],mtype=mtype)
 
            # save cl for each rlz
            if verbose:  print('output aps to',aobj.fcls['c'][rlz])
            np.savetxt(aobj.fcls['c'][rlz],np.concatenate((aobj.l[None,:],cl['c'][ii,:,:])).T)
            if verbose:  print('output aps to',aobj.fcls['n'][rlz])
            np.savetxt(aobj.fcls['n'][rlz],np.concatenate((aobj.l[None,:],cl['n'][ii,:,:])).T)

        # save mean cl to files
        if aobj.rlz[-1] >= 2:
            if verbose:  print('save averaged spectrum over rlz')
            imin = max(0,1-aobj.rlz[0]) 
            for s in ['c','n']:
                if misctools.check_path(aobj.fscl[s],overwrite=overwrite,verbose=verbose): continue
                np.savetxt(aobj.fscl[s],np.concatenate((aobj.l[None,:],np.mean(cl[s][imin:,:,:],axis=0),np.std(cl[s][imin:,:,:],axis=0))).T)


def alm_supfac(qids,w1=None,overwrite=False,verbose=True,**kwargs):

    del kwargs['snmin'] # set snmin to 1 below
    
    for qid in qids:

        aobj = local.init_analysis_params(qid=qid,snmin=1,**kwargs)

        if misctools.check_path(aobj.fsup,overwrite=overwrite,verbose=verbose): continue

        if w1 is None:
            mask_iv = load_mask(qid)
            mask_hp = enmap.to_healpix(mask_iv,nside=aobj.nside)
            W1 = get_wfactor(mask_hp)[1]
        else:
            W1 = w1
            
        lmax = aobj.lmax
        rl = np.zeros((len(aobj.rlz),lmax+1))

        for ii, rlz in enumerate(tqdm.tqdm(aobj.rlz)):
 
            # projected signal alm
            Tlm_obs = pickle.load(open(aobj.falm['s']['T'][rlz],"rb"))
            
            # input fullsky signal alm
            f = '/project/projectdirs/act/data/actsims_data/signal_v0.4/fullskyLensedUnabberatedCMB_alm_set00_'+str(rlz).zfill(5)+'.fits'
            Tlm_inp = np.complex128( hp.fitsfunc.read_alm( f, hdu = (1) ) ) / local.Tcmb
            ilmax = hp.sphtfunc.Alm.getlmax(len(Tlm_inp))
            Tlm_inp = curvedsky.utils.lm_healpy2healpix(len(Tlm_inp), Tlm_inp, ilmax)[:lmax+1,:lmax+1]

            # obs x input
            xl = curvedsky.utils.alm2cl(lmax,Tlm_obs,Tlm_inp)
            
            # input auto
            cl = curvedsky.utils.alm2cl(lmax,Tlm_inp)
            
            # take ratio to get suppression factor
            rl[ii,2:] = xl[2:]/cl[2:]

        # save to file
        mrl = np.mean(rl,axis=0)
        np.savetxt( aobj.fsup, np.array( ( aobj.l, mrl, mrl/W1 ) ).T )
        


def comb_Nl(qids,ncl,rcl=None):

    Nl = 0.*ncl[qids[0]]
    
    for q in qids:
        if rcl is None:
            Nl[2:] += 1./ncl[q][2:]
        else:
            Nl[2:] += rcl[q][2:]**2/ncl[q][2:]
    Nl[2:] = 1./Nl[2:]
    return Nl



def alm_comb(qids,qidc,overwrite=False,verbose=True,mtype=['T'],ep=1e-30,**kwargs):

    # qids = qid to be combined
    # qidc = output qid
    
    aobj = {q: local.init_analysis_params(qid=q,**kwargs) for q in qids+[qidc]}

    # pre-computed spectra
    #mcl  = {q: (np.loadtxt(aobj[q].fscl['c'])).T[1] for q in qids}
    ncl  = {q: (np.loadtxt(aobj[q].fscl['n'])).T[1] for q in qids}
    # sup fac
    #fcl  = {q: (np.loadtxt(aobj[q].fsup)).T[1] for q in qids}
    rcl  = {q: (np.loadtxt(aobj[q].fsup)).T[2] for q in qids}
    Ncl  = comb_Nl(qids,ncl,rcl)
    #Ncl  = comb_Nl(qids,ncl)

 
    w1 = {}
    for qid in qids:
        mask_iv = load_mask(qid)
        mask_hp = enmap.to_healpix(mask_iv,nside=aobj[qid].nside)
        w1[qid] = get_wfactor(mask_hp)[1]

    
    for rlz in tqdm.tqdm(aobj[qids[0]].rlz):

        if misctools.check_path([aobj[qidc].falm['c']['T'][rlz],aobj[qidc].falm['n']['T'][rlz]],overwrite=overwrite,verbose=verbose): continue

        wTlm = {}
        for s in ['c','s','n']:
            for m in mtype:
                if rlz == 0 and s in ['s','n']: continue
                wTlm[s,m] = 0.
                for q in qids:
                    # walm = 1/N alm = 1/(N/r^2) alm/r
                    #wTlm[s,m] += 1./ncl[q][:,None] * pickle.load(open(aobj[q].falm[s]['T'][rlz],"rb")) / w1[q]
                    wTlm[s,m] += rcl[q][:,None]/(ncl[q][:,None]+ep) * pickle.load(open(aobj[q].falm[s]['T'][rlz],"rb")) #/ w1[q]
                    wTlm[s,m][:2,:] = 0.
        
                wTlm[s,m] *= Ncl[:,None]
                # save alm for each rlz
                pickle.dump((wTlm[s,m]),open(aobj[qidc].falm[s][m][rlz],"wb"),protocol=pickle.HIGHEST_PROTOCOL)
                pickle.dump((wTlm[s,m]),open(aobj[qidc].falm[s][m][rlz],"wb"),protocol=pickle.HIGHEST_PROTOCOL)



def diff_day_night(overwrite=False,verbose=True,mtype=['T'],**kwargs):

    qid  = 'diff_dn'
    aobj = {q: local.init_analysis_params(qid=q,**kwargs) for q in ['comb_d','comb_n',qid]}

    cl = {}
    for s in ['c','s','n']:
        cl[s] = np.zeros((len(aobj[qid].rlz),6,aobj[qid].lmax+1))

    for ii, rlz in enumerate(tqdm.tqdm(aobj['comb_d'].rlz)):

        if misctools.check_path(aobj['diff_dn'].falm['c']['T'][rlz],overwrite=overwrite,verbose=verbose): continue

        for s in ['c','s','n']:
            
            if rlz==0 and s in ['s','n']: continue

            Talm0 = pickle.load(open(aobj['comb_d'].falm[s]['T'][rlz],"rb")) / 0.016
            Talm1 = pickle.load(open(aobj['comb_n'].falm[s]['T'][rlz],"rb")) / 0.02
        
            # save diff alm for each rlz
            pickle.dump((Talm0-Talm1),open(aobj['diff_dn'].falm[s]['T'][rlz],"wb"),protocol=pickle.HIGHEST_PROTOCOL)

            cl[s][ii,0,:] = curvedsky.utils.alm2cl(aobj[qid].lmax,Talm0-Talm1)
        
            # save cl for each rlz
            np.savetxt(aobj[qid].fcls[s][rlz],np.concatenate((aobj[qid].l[None,:],cl[s][ii,:,:])).T)

    # save mean cl to files
    if aobj[qid].rlz[-1] >= 2:
        if verbose:  print('save averaged diff day-night spectrum')
        imin = max(0,1-aobj[qid].rlz[0]) 
        for s in ['c','s','n']:
            np.savetxt(aobj[qid].fscl[s],np.concatenate((aobj[qid].l[None,:],np.mean(cl[s][imin:,:,:],axis=0),np.std(cl[s][imin:,:,:],axis=0))).T)

        
        
def alm2aps_null(qid,overwrite=False,verbose=True,mtype=['T'],ep=1e-30,**kwargs):

    pid = qid.replace('_d0','_0')
    if 's16' in qid:
        pid = qid.replace('s16','boss')

    aobj = {q: local.init_analysis_params(qid=q,**kwargs) for q in [qid,pid]}

    mask_iv0 = load_mask(qid)
    mask_hp0 = enmap.to_healpix(mask_iv0,nside=aobj[qid].nside)
    mask_iv1 = load_mask(pid)
    mask_hp1 = enmap.to_healpix(mask_iv1,nside=aobj[pid].nside)

    w2 = np.average(mask_hp0**2)
    x2 = np.average(mask_hp0*mask_hp1)

    cl = np.zeros((len(aobj[qid].rlz),6,aobj[qid].lmax+1))
    xl = np.zeros((len(aobj[qid].rlz),6,aobj[qid].lmax+1))

    for ii, rlz in enumerate(tqdm.tqdm(aobj[qid].rlz)):

        #if misctools.check_path(aobj[qid].fnul['c'][rlz],overwrite=overwrite,verbose=verbose): continue

        Talm0 = pickle.load(open(aobj[qid].falm['c']['T'][rlz],"rb"))
        Talm1 = pickle.load(open(aobj[pid].falm['c']['T'][rlz],"rb"))
        cl[ii,0,:] = curvedsky.utils.alm2cl(aobj[qid].lmax,Talm0-Talm1) / w2
        xl[ii,0,:] = curvedsky.utils.alm2cl(aobj[qid].lmax,Talm0,Talm1) / x2
        
        # save cl for each rlz
        np.savetxt(aobj[qid].fcls_nul[rlz],np.concatenate((aobj[qid].l[None,:],cl[ii,:,:])).T)
        np.savetxt(aobj[qid].fcls_x[rlz],np.concatenate((aobj[qid].l[None,:],xl[ii,:,:])).T)

    # save mean cl to files
    if aobj[qid].rlz[-1] >= 2:
        if verbose:  print('cmb alm2aps: save sim')
        imin = max(0,1-aobj[qid].rlz[0]) 
        np.savetxt(aobj[qid].fscl_nul,np.concatenate((aobj[qid].l[None,:],np.mean(cl[imin:,:,:],axis=0),np.std(cl[imin:,:,:],axis=0))).T)
        np.savetxt(aobj[qid].fscl_x,np.concatenate((aobj[qid].l[None,:],np.mean(xl[imin:,:,:],axis=0),np.std(xl[imin:,:,:],axis=0))).T)


